[[toc]]
# Поддержка lua скриптов (Draft)

## Введение
Шлюз SLS самодостаточен и может обходиться без внешних систем управления Умным домом. Для реализации автоматизаций, он поддерживает скриптовый язык программирования [LUA](https://ru.wikipedia.org/wiki/Lua).
При разработке скриптов можно использовать функции как встроенные в прошивку шлюза, так и функции поддерживаемых шлюзом библиотек LUA.
<!--	#ToDo - какие библиотеки встроены в прошивку
		известны из доков:
		os
		string
		table
		...
 -->
Текущая, поддерживаемая, версия [LUA 5.4.4](https://www.lua.org/versions.html#5.4) (с версии прошивки 2022.01.30d1). 
## Соглашения
Немного о форматировании и названиях различных объектов шлюза.

Для работы с различными объектами используется формат кода типа `zigbee.getStatus()`. В терминологии LUA это выглядит как `библиотека.функция()`. Поэтому постараемся придерживаться подобного именования объектов SLS.

Форматирование текста:
- пункты меню: *File -> Save* 
- небольшие куски кода: `print(a)`
- многострочный код:
```lua
local var = 0
print(var)
```
Описание синтаксиса:
```lua
function("var1(STR)", var2(INT)[, var3(BOOL)])
-- в скобках после имени переменной указан её тип
-- если тип не указан, значит можно передавать любой
-- если переменная указана в кавчках, значит ее нужно так и описывать в коде
-- в [квадратных] скобках указаны необязательные переменные
```
---
>let's begin
## Асинхронное программирование
Немного о модели программирования для нашего шлюза. При проектировании алгоритмов лучше не использовать функции а-ля os.delay() и самописные аналоги, выполняющие паузы в работе сценария более 1 секунды. Вместо этого лучше проектировать вызовы кусков кода из разных скриптов. 

Например, часто при включении света в техническом или проходном помещении, необходимо сделать паузу и свет выключить. Первое, что приходит в голову - это сделать паузу в теле текущего сценария. Но, правильнее передать управление другому скрипту или вызвать основной [рекурсивно](/lua_doc/luaMainDoorLight.md).  
Об асинхронности в программировании можно почитать, например [здесь](https://habr.com/ru/company/jugru/blog/446562).

---
## Примеры кода
Все примеры скриптов собраны [здесь](/lua_doc/luaExamples.md)

---
## Редактор скриптов и отладка
Редактор скриптов, по совместительству с файловым менеджером предназначен для создания, удаления и редактирования файлов, в том числе и скриптов. 
Найти его можно в меню *Actions -> Files* (в старых версиях прошивки *Actions -> Scripts*).<!--	#ToDo - с какой версии прошивки? -->
![](/img/luaScriptEditor.png)
Редактор разделен на несколько областей:
- Меню, с кнопками:
  - *Toggle files* - скрыть / отобразить панель файлов
  - *Save* - сохранить
  - *Run* - запустить скрипт на исполнение
  - *Clear output* - очистить панель вывода
- Панель *Files*. Позволяет управлять файлами:
  - Создать - *New file*
  - Удалить - значок корзины напротив имени каждого файла
  - Открыть на редактирование - каждый файл представляет собой ссылку, по которой файл открывается в панели редактора
- Панель редактора
- Панель вывода - консоль для вывода результатов работы редактируемого скрипта

Скриптовый `stdout` функции LUA `print()` выводит информацию на Панель вывода, а также в системный лог (меню *Log*) шлюза. Данную функцию удобно использовать для отладки.

Для разработки или отладки скрипта, необходимо создать новый файл или открыть существующий. Например, с именем `test.lua` и в него ввести код на языке LUA. 

Отладка скриптов выполняется преимущественно в Редакторе скриптов SLS. Однако, некоторые пользовательские функции может быть удобнее разрабатывать во "взрослых" IDE. Например, нативный [ZeroBrain Studio](https://studio.zerobrane.com), VS Code, Atom и других. 

---
## Запуск скриптов
В зависимости от задач, выполняемых той или иной автоматизацией, доступны несколько вариантов запуска скриптов:
1. [из скрипта инициализации](/lua_doc/luaDoc.md#скрипт-инициализации)
2. [при изменении состояния устройства](/lua_doc/luaDoc.md#запуск-скрипта-при-изменении-состояния-устройства)
3. [по событию изменения объекта](luaDoc.md#запуск-скрипта-по-событию-изменения-объекта) <!--	#ToDo - в документации вендора данный пункт ссылается на несуществующий раздел? -->
4. [запуск из другого скрипта](luaDoc.md#запуск-lua-скрипта-из-другого-скрипта)
5. [с помощью  http api](luaDoc.md#запуск-скрипта-с-помощью-http-api)
6. [периодический запуск (таймеры)](luaDoc.md#периодический-запуск-скриптов-таймеры)
7. по подписке mqtt (в разработке).

### Скрипт инициализации
При запуске системы выполняется скрипт инициализации `init.lua`, если он есть. Перед началом работы со скриптами, рекомендуется проверить его наличие рядом со всеми остальными скриптами `*.lua`. Если файла нет, то его нужно в редакторе скриптов.  В `init.lua` полезно инициализировать переменные для работы с устройством, а также выполнить какие либо действия. [Например:](/lua_doc/luaExamples.md#скрипт-инициализации)
```lua
-- init.lua --
-- Уведомление в Telegram о старте шлюза --
telegram.settoken("51778***5:AAG0bvK***")
telegram.setchat("-3348***")
telegram.send("SLS загружен!!!")
```

### Запуск скрипта при изменении состояния устройства
Скрипт можно запускать как одно из правил [SimpleBind](/simplebind_rus.md).

Синтаксис: `scriptname.lua[,Param]`

Например, так может выглядеть запись SB Rule для датчика открытия ![](/img/luaSBRule.png)
- `mainDoorOnLight.lua` - имя запускаемого скрипта
- `Param` - необязательный параметр, через который в скрипт можно передать необходимые аргументы. Принимается он в скрипте через Событие `Event.Param`
Аргументов может быть несколько. В данном примере передается 3 аргумента, разделенные символом `:`: целевое устройство, которым должен управлять датчик по сработке; контролируемый статус; задержка управляющего действия. Если аргументы не прописывать, то при изменении условий, придется менять эти значения в теле скрипта. Пример похожего скрипта [здесь](/lua_doc/luaMainDoorLight.md)

### Запуск скрипта по событию изменения объекта
Привязка к объекту скрипта, который будет выполняться при каждом изменении объекта
```lua
obj.onChange("Name"(STR), "script.lua"(STR))
-- Name - имя объекта
-- script.lua - имя файла скрипта с расширением
```
Данные объекта в вызываемый скрипт передаются через событие с типом `SCRIPT_EVENT_TYPE_OBJ_CHANGE` и значением `2`. Получить данные можно, например, так:
```lua
if Event.Type == 2 then
  local Name = Event.Obj.Name -- имя объекта
  local Value = Event.Obj.Value -- значение 
  local OldValue = Event.Obj.OldValue -- предыдущее значение
  local Ack = Event.Obj.Ack -- статус флага обратной связи
end
```
 
### Запуск LUA скрипта из другого скрипта

Синтаксис: `dofile("/int/script.lua"[, Param])`
<!-- ToDo добавить параметры, если они есть -->

### Запуск скрипта с помощью HTTP API

Скрипт SLS можно вызвать из внешней системы используя [HTTP API](/http_api_rus.md):
`/api/scripts?action=evalFile&path=/test.lua`

### Периодический запуск скриптов из планировщика
Шлюз может запускать скрипты с определенной периодичностью. Можно установить таймер запуска к любому скрипту, а так же отменить его. Дискретность таймеров 1 секунда, для Cron - 1 минута.

Типы таймеров:
- Периодический. Выполняется каждые `X` секунд. `Event.Type = 5`
  ```lua
  scripts.setTimer("script"(STR), t(INT)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- t - уставка времени в сек. Для сброса таймера: `t = 0`
  -- Param - аргументы, передаваемые в скрипт
  ```
- Однократный.  Выполняется однократно в UNIX время. `Event.Type = 4`
  ```lua
  scripts.setTimer("script"(STR), os.time() + t(INT)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- os.time() - функциия LUA, возвращает UNIX время на текущий момент в сек.
  -- t - уставка времени в сек. Для сброса таймера: `t = 0`
  -- Param - аргументы, передаваемые в скрипт
  ```
- Cron. `Event.Type = 6`. Добавлен в версии прошивки 2022.04.24d11. Синтаксис как у [UNIX cron](https://ru.wikipedia.org/wiki/Cron) 
```lua
  scripts.setTimer("script"(STR), "crontab"(STR)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- crontab - уставка времени в формате UNIX CRON 
  --[[ TODO - проверить есть ли здесь поддержка Param]]
```
[Примеры](/lua_doc/luaExamples.md#таймеры)

Если выполнить подряд несколько установок таймера для одного целевого скрипта, то настройка применяется из последней итерации.

Например, скрипт привязан к датчику движения и при каждой сработке настраивает однократный таймер запуска исполняющего скрипта. При этом, если основной скрипт успевает запуститься несколько раз до сработки таймера, то уставка времени будет из последней итерации. 

**Внимание, скрипты OneMinTimer.lua и OneSecTimer.lua более не запускаются автоматически!!! (с версии прошивки 2022.01.30d1)**

---
## Встроенные библиотеки
В прошивку шлюза встроены следующие библиотеки:
- [obj.](/lua_doc/luaDoc.md#работа-с-объектами) 
- [Event.](/lua_doc/luaDoc.md#события)
- [zigbee.](/lua_doc/luaDoc.md#библиотека-zigbee)
- [mqtt.](/lua_doc/luaDoc.md#mqttpub) 
- [http.](/lua_doc/luaDoc.md#httprequest)
- [telegram.](/lua_doc/luaDoc.md#)

Огромное количество примеров использования [здесь](/lua_doc/luaExamples.md). (в разработке)


### Работа с объектами
Объекты это универсальная сущность для хранения и обмена данными между подсистемами шлюза, например между скриптами. [Подробнее здесь](/objects_rus.md). [Примеры](/lua_doc/luaExamples.md).

Синтаксис функций:
#### obj.setOpt()
Инициализация объекта, изменения типа данных, записываемых в объект, управление флагом передачи уведомлений в MQTT
```lua
obj.setOpt("Name"(STR), "type"(STR)[, flagMQTT(BOOL)])
-- Name - имя объекта
-- type - тип хранимых данных: STR, INT, BOOL, FLOAT
-- flagMQTT - флаг передачи уведомлений в MQTT
  -- false = передача выключена
  -- true = передача включена. В таблице объектов (WebUI/Objects) отображается сомволом N (Notify)
```
#### obj.set()
Запись данных в объект, управление флагом обратной связи. При первом вызове - инициализация объекта.
```lua
obj.set("Name"(STR), value[, flagACK(BOOL)])
-- Name - имя объекта
-- value - записываемые данные, любого типа
-- flagACK - флаг обратной связи
  -- true = включен. В таблице объектов отображается символом A (ACK)
  -- false = выключен. В таблице объектов не отображается
```
#### obj.get()
Получение данных, хранящихся в объекте
```lua
obj.get("Name"(STR))
-- Name - имя объекта
```
В объекте хранится текущее значение, предыдущее и состояние флага ACK. Также хранится тайм-штампы записи текущего значения  и предыдущего, которые можно получить следующей функцией. Для получения всех значений можно использовать такой код:
```lua
current_value, previos_value, flag_ack = obj.get("object_name")
-- переменные будут содержать:
-- current_value = текущее значение
-- previos_value = предыдущее значение
-- flag_ack = статус флага ACK 
```
#### obj.getTime()
Получение тайм-штампов изменения текущего и предыдущего значений. Оба значения можно получить так-же как в `obj.get()`
```lua
obj.getTime("Name"(STR))
-- имя объекта
```
#### obj.onChange()
Привязка к объекту скрипта, который будет выполняться при каждом изменении объекта
```lua
obj.onChange("Name"(STR), "script.lua"(STR))
-- Name - имя объекта
-- script.lua - имя файла скрипта с расширением
```
#### obj.remove()
Удаление объекта
```lua
obj.remove("Name"(STR))
-- Name - имя объекта
```
### События
Библиотека `Event` служит для передачи данных в скрипт, в зависимости от того, из какой подсистемы он вызван.
### Типы событий
События различаются типом `Event.Type`. В скрипт передается числовое значение типа события, позволяющее определить источник вызова и получить различные параметры:

1. [Вызов по изменению состояния привязанного сенсора](/lua_doc/luaDoc.md#Вызов-из-SB-Rule). Правило Simple Bind. 
2. [Вызов по изменению объекта](/lua_doc/luaDoc.md#Вызов-по-изменению-объекта). `SCRIPT_EVENT_TYPE_OBJ_CHANGE` 
3.  
4. [Таймер однократный.](/lua_doc/luaDoc.md#Вызов-по-однократному-таймеру)
5. [Таймер периодический.](/lua_doc/luaDoc.md#Вызов-по-периодическому-таймеру)
6. [Таймер Cron.](/lua_doc/luaDoc.md#Вызов-по-таймеру-Cron)
### Свойства событий
Для всех типов событий передаются следующие свойства:
- `Event.Type` - тип события INT
- `Event.Name` - имя файла вызванного скрипта с расширением
- `Event.Time` - время вызова скрипта `table(sec, min, hour, day, wday, month, year)`. 

#### Вызов из SB Rule
- `Event.Param` - аргументы
- `Event.nwkAddr` - nwkAddr вызывающего устройства
- `Event.ieeeAddr` - ieeeAddr вызывающего устройства
- `Event.ModelId` - ModelId вызывающего устройства
- `Event.FriendlyName` - FriendlyName вызывающего устройства
- `Event.State.Name` - имя вызывающего "состояния"
- `Event.State.Value` - текущее значение "состояния"
- `Event.State.OldValue` - предыдущее значение "состояния"

#### Вызов по изменению объекта
- `Event.Obj.Name` - имя объекта, который вызвал скрипт
- `Event.Obj.Ack` - флаг обратной связи объекта
- `Event.Obj.Value` - текущее значение
- `Event.Obj.OldValue` - предыдущее значение

#### Вызов по однократному таймеру
- `Event.Param` - аргументы

#### Вызов по периодическому таймеру
- `Event.Param` - аргументы

#### Вызов по таймеру Cron 
<!-- - `Event.Param` - аргументы -->

### Библиотека zigbee
Служит для управления zigbee устройствами, зарегистрированными на шлюзе. Подробные примеры [здесь](/lua_doc/luaExamples.md#zigbee)

#### zigbee.join()
Включает режим сопряжения для подключения новых устройств
```lua
zigbee.join(duration(INT)[, "router"(STR)])
-- duration - время в секундах, на которое включить Join
-- router - FriendlyName, ieeeAddr или nwkAddr устройства - роутера. Если опустить этот параметр, сопряжение будет открыто для всей сети
```
#### zigbee.value()
Возвращает значения состояния устройства из кэша 
```lua
zigbee.value("device"(STR), "state"(STR))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- state - состояние, значение которого необходимо получить
```
#### zigbee.get()
Возвращает значения состояния устройства вызовом функции GET в конвертере
```lua
zigbee.get("device"(STR), "state"(STR))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- state - состояние, значение которого необходимо получить
```
#### zigbee.set()
Устанавливает значение состояния устройства
```lua
zigbee.set("device"(STR), "stateName"(STR), stateValue)
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- stateName - имя состояния, значение которого необходимо изменить
-- stateValue - значение состояние. Тип - свой для каждого значения. Например, для кнопки State:Action тип будет STR, а для яркости State:brightness тип будет INT 
```
#### zigbee.setState()
Устанавливает значение состояния устройства. Можно указать тип значения (по умолчанию STR) и необходимо ли выполнять события (по умолчанию true).
Начиная с версии 2022.07.24d1.

```lua
zigbee.setState("device"(STR), "stateName"(STR), stateValue[[, "type"(STR)], events])


zigbee.setState("0x00124B001E1EB5C0", "my_count", 5, "INT")
```

TODO - setState скудно описан. Разобраться. По идее нужен для создания кастомных стэйтов и вроде как устройств и управлении ими. При этом управляется также и через set(), но как-то криво, например: есть color_temp, создал color_temp1. При изменении color_temp1 через set() - меняется также и color_temp. Как удалить созданного стэйта. Разобраться с флагом events. Как читать состояние флага? 





zigbee.setState(ident, name, value[[, type], events])
zigbee.readAttr(ident, epId, clusterId, AttrId[, manufId])
zigbee.writeAttr(ident, epId, clusterId, AttrId, dataType, value[, manufId])
zigbee.configReport(ident, epId, clusterId, AttrId, dataType, minRepInt, maxRepInt, repChange)
zigbee.getStatus()



### 
### zigbee.readAttr(ident, epId, clusterId, AttrId[, manufId])
Отправляет запрос на чтение атрибута в кластере.

Читает атрибут swBuild в кластере genBasic в 1 эндпоинте:
```lua
zigbee.readAttr("0x90FD9FFFFEF7E26D", 0x0000, 1, 0x4000)
```

### zigbee.writeAttr(ident, epId, clusterId, AttrId, dataType, value[, manufId])
Записывает значение атрибута в кластере.

### zigbee.configReport(ident, epId, clusterId, AttrId, dataType, minRepInt, maxRepInt, repChange)
Конфигурирует репортинг атрибута в кластере.

### zigbee.getStatus()
Возвращает статус координатора, если запущен успешно - 9.
Начиная с версии 2022.07.24d1.

```lua
coord_status = zigbee.getStatus()
```

------------------------------------------------------------------




### http.request 
Вызов URL запроса http.request (`url[:port], [method, headers, body]`)

В данный момент поддерживается только `http://` протокол.

Пример переключение gpio 12 для прошивки wifi-iot
```lua
http.request("http://192.168.1.34/gpio?st=2&pin=12")
```

Пример отправки POST запроса:
```lua
http.request("http://postman-echo.com:80/post?foo1=bar1", "POST", "Content-Type: text/text; charset=utf-8\r\n", "body") 
```

Пример переключения реле sw1 в прошивке espHome:

```lua
http.request("http://192.168.1.71/switch/sw1/toggle", "POST") 
```

Пример переключение gpio для MegaD при однократном нажатии btn_2 пульта Jager
```lua
if Event.State.Value == "btn_2_single"  then
  http.request("http://192.168.2.200/objects/?object=MegaD1-12&op=m&m=switch")
end
```

Запрос инфомации со стороннего ресурса
```lua
local Response = http.request("http://wtfismyip.com/text")
print("My IP: " .. Response)
```
