[[toc]]
# Поддержка lua скриптов (Draft)

## Введение
Шлюз SLS самодостаточен и может обходиться без внешних систем управления Умным домом. Для реализации автоматизаций, он поддерживает скриптовый язык программирования [LUA](https://ru.wikipedia.org/wiki/Lua).
При разработке скриптов можно использовать функции как встроенные в прошивку шлюза, так и функции поддерживаемых шлюзом библиотек LUA.
<!--	#ToDo - какие библиотеки встроены в прошивку
		известны из доков:
		os
		string
		table
		...
 -->
Текущая, поддерживаемая, версия [LUA 5.4.4](https://www.lua.org/versions.html#5.4) (с версии прошивки 2022.01.30d1). 
## Соглашения
Немного о форматировании и названиях различных объектов шлюза.

Для работы с различными объектами используется формат кода типа `zigbee.getStatus()`. В терминологии LUA это выглядит как `библиотека.функция()`. Поэтому постараемся придерживаться подобного именования объектов SLS.

Форматирование текста:
- пункты меню: *File -> Save* 
- небольшие куски кода: `print(a)`
- многострочный код:
```lua
local var = 0
print(var)
```
Описание синтаксиса:
```lua
function("var1(STR)", var2(INT)[, var3(BOOL)])
-- в скобках после имени переменной указан её тип
-- если тип не указан, значит можно передавать любой
-- если переменная указана в кавчках, значит ее нужно так и описывать в коде
-- в [квадратных] скобках указаны необязательные переменные
```
>let's begin
## Примеры скриптов
Все примеры скриптов собраны [здесь](/lua_doc/luaExamples.md)

## Редактор скриптов и отладка
Редактор скриптов, по совместительству с файловым менеджером предназначен для создания, удаления и редактирования файлов, в том числе и скриптов. 
Найти его можно в меню *Actions -> Files* (в старых версиях прошивки *Actions -> Scripts*).<!--	#ToDo - с какой версии прошивки? -->
![](/img/luaScriptEditor.png)
Редактор разделен на несколько областей:
- Меню, с кнопками:
  - *Toggle files* - скрыть / отобразить панель файлов
  - *Save* - сохранить
  - *Run* - запустить скрипт на исполнение
  - *Clear output* - очистить панель вывода
- Панель *Files*. Позволяет управлять файлами:
  - Создать - *New file*
  - Удалить - значок корзины напротив имени каждого файла
  - Открыть на редактирование - каждый файл представляет собой ссылку, по которой файл открывается в панели редактора
- Панель редактора
- Панель вывода - консоль для вывода результатов работы редактируемого скрипта

Скриптовый `stdout` функции LUA `print()` выводит информацию на Панель вывода, а также в системный лог (меню *Log*) шлюза. Данную функцию удобно использовать для отладки.

Для разработки или отладки скрипта, необходимо создать новый файл или открыть существующий. Например, с именем `test.lua` и в него ввести код на языке LUA. 

Отладка скриптов выполняется преимущественно в Редакторе скриптов SLS. Однако, некоторые пользовательские функции может быть удобнее разрабатывать во "взрослых" IDE. Например, нативный [ZeroBrain Studio](https://studio.zerobrane.com), VS Code, Atom и других. 

## Запуск скриптов
В зависимости от задач, выполняемых той или иной автоматизацией, доступны несколько вариантов запуска скриптов:
1. [из скрипта инициализации](/lua_doc/luaDoc.md#скрипт-инициализации)
2. [при изменении состояния устройства](/lua_doc/luaDoc.md#запуск-скрипта-при-изменении-состояния-устройства)
3. [по событию изменения объекта](luaDoc.md#запуск-скрипта-по-событию-изменения-объекта) <!--	#ToDo - в документации вендора данный пункт ссылается на несуществующий раздел? -->
4. [запуск из другого скрипта](luaDoc.md#запуск-lua-скрипта-из-другого-скрипта)
5. [с помощью  http api](luaDoc.md#запуск-скрипта-с-помощью-http-api)
6. [периодический запуск (таймеры)](luaDoc.md#периодический-запуск-скриптов-таймеры)
7. по подписке mqtt (в разработке).

### Скрипт инициализации
При запуске системы выполняется скрипт инициализации `init.lua`, если он есть. Перед началом работы со скриптами, рекомендуется проверить его наличие рядом со всеми остальными скриптами `*.lua`. Если файла нет, то его нужно в редакторе скриптов.  В `init.lua` полезно инициализировать переменные для работы с устройством, а также выполнить какие либо действия. [Например:](/lua_doc/luaExamples.md#скрипт-инициализации)
```lua
-- init.lua --
-- Уведомление в Telegram о старте шлюза --
telegram.settoken("51778***5:AAG0bvK***")
telegram.setchat("-3348***")
telegram.send("SLS загружен!!!")
```

### Запуск скрипта при изменении состояния устройства
Скрипт можно запускать как одно из правил [SimpleBind](/simplebind_rus.md).

Синтаксис: `scriptname.lua[,Param]`

Например, так может выглядеть запись SB Rule для датчика открытия ![](/img/luaSBRule.png)
- `mainDoorOnLight.lua` - имя запускаемого скрипта
- `Param` - необязательный параметр, через который в скрипт можно передать необходимые аргументы. Принимается он в скрипте через Событие `Event.Param`
<!--	#ToDo - добавить ссылку на описание событий -->
Аргументов может быть несколько. В данном примере передается 3 аргумента, разделенные символом `:`: целевое устройство, которым должен управлять датчик по сработке; контролируемый статус; задержка управляющего действия. Если аргументы не прописывать, то при изменении условий, придется менять эти значения в теле скрипта. Пример похожего скрипта [здесь](/lua_doc/luaMainDoorLight.md)

### Запуск скрипта по событию изменения объекта
[Синтаксис: `obj.onChange('objName', 'script.lua')`](/lua_doc/luaDoc.md#obj-onChange-(-))
- `objName` - имя контролируемого объекта
- `script.lua` - имя скрипта, вызываемого при возникновении события

[Например](/lua_doc/luaExamples.md#Включение-режима-сопряжения-по-нажатию-на-кнопку-шлюза), можно вызвать скрипт по событию нажатия аппаратной кнопки шлюза. Реагировать можно на объекты `io.input0.*`. Включим "режим сопряжения" по нажатию на кнопку:
1. в `init.lua` добавить код: `obj.onChange("io.input0.value", "btn_sw1.lua")`
2. создать `btn_sw1.lua` с кодом: `zigbee.join(255, "0x0000")`
<!--	#ToDo - добавить ссылку на описание join  -->
 
### Запуск LUA скрипта из другого скрипта

Синтаксис: `dofile("/int/script.lua"[, Param])`
<!-- ToDo добавить параметры, если они есть -->

### Запуск скрипта с помощью HTTP API

Скрипт SLS можно вызвать из внешней системы используя [HTTP API](/http_api_rus.md):
`/api/scripts?action=evalFile&path=/test.lua`

### Периодический запуск скриптов из планировщика
Шлюз может запускать скрипты с определенной периодичностью. Можно установить таймер запуска к любому скрипту, а так же отменить его. Дискретность таймеров 1 секунда, для cron - 1 минута.

Типы таймеров:
- Периодический. Выполняется каждые `X` секунд. `Event.Type = 5`
  - Синтаксис: `scripts.setTimer("script", t[, Param])`
- Однократный.  Выполняется однократно в UNIX время. `Event.Type = 4`
  - Синтаксис: `scripts.setTimer("script", os.time() + t[, Param])`
- Cron. `Event.Type = 6`. Добавлен в версии прошивки от 2022.04.24d11
  - Синтаксис как у [UNIX cron](https://ru.wikipedia.org/wiki/Cron) 
- где:
  - `script` - имя файла скрипта, без расширения `lua`
  - `t` - уставка времени в сек. Для сброса таймера: `t = 0`
  - `Param` - параметры передаваемые в скрипт

Примеры:

Запуск скрипта каждые 60 секунд:
```lua
scripts.setTimer("getMoney", 60, "$")
```
Запуск скрипта через 5 минут, однократно:
```lua
scripts.setTimer("giveMoney", os.time() + 300)
```
Запуск скрипта каждый день в 01:05:
```lua
scripts.setTimer("earnMoney", "5 1 * * *")
```
Сброс таймера для скрипта OneMinTimer.lua:
```lua
scripts.setTimer("OneMinTimer", 0)
```
Если все 4 примера выполнить подряд для одного скрипта, то настройка применяется из последней команды. В нашем случае таймер будет отключен. 

Например, скрипт привязан к датчику движения и при каждой сработке настраивает однократный таймер запуска исполняющего скрипта. При этом, если скрипт успевает запуститься несколько раз до сработки таймера, то уставка времени будет из последней итерации. 

**Внимание, скрипты OneMinTimer.lua и OneSecTimer.lua более не запускаются автоматически!!! (с версии прошивки 2022.01.30d1)**

## Встроенные библиотеки
В прошивку шлюза встроены следующие библиотеки:
- [obj.](lua_rus.md#Работа-с-объектами) 
- [Event.](lua_rus.md#event)
- [zigbee.](lua_rus.md#zigbeevalue)
- [mqtt.](lua_rus.md#mqttpub) 
- [http.](lua2_rus.md#httprequest)
- [telegram.](lua2_rus.md#)

Огромное количество примеров использования [здесь](/lua_doc/luaExamples.md).


### Работа с объектами
Объекты это универсальная сущность для хранения и обмена данными между подсистемами шлюза, например между скриптами. [Подробнее здесь](/objects_rus.md). [Примеры](/lua_doc/luaExamples.md).

Синтаксис функций:
#### obj.setOpt()
Инициализация объекта, изменения типа данных, записываемых в объект, управление флагом передачи уведомлений в MQTT
```lua
obj.setOpt("Name"(STR), "type"(STR)[, flagMQTT(BOOL)])
-- Name - имя объекта
-- type - тип хранимых данных: STR, INT, BOOL, FLOAT
-- flagMQTT - флаг передачи уведомлений в MQTT
  -- false = передача выключена
  -- true = передача включена. В таблице объектов (WebUI/Objects) отображается сомволом N (Notify)
```
#### obj.set()
Запись данных в объект, управление флагом обратной связи. При первом вызове - инициализация объекта.
```lua
obj.set("Name"(STR), value[, flagACK(BOOL)])
-- Name - имя объекта
-- value - записываемые данные, любого типа
-- flagACK - флаг обратной связи
  -- true = включен. В таблице объектов отображается символом A (ACK)
  -- false = выключен. В таблице объектов не отображается
```
#### obj.get()
Получение данных, хранящихся в объекте
```lua
obj.get("Name"(STR))
-- Name - имя объекта
```
В объекте хранится текущее значение, предыдущее и состояние флага ACK. Также хранится тайм-штампы записи текущего значения  и предыдущего, которые можно получить следующей функцией. Для получения всех значений можно использовать такой код:
```lua
current_value, previos_value, flag_ack = obj.get("object_name")
-- переменные будут содержать:
-- current_value = текущее значение
-- previos_value = предыдущее значение
-- flag_ack = статус флага ACK 
```
#### obj.getTime()
Получение тайм-штампов изменения текущего и предыдущего значений. Оба значения можно получить так-же как в `obj.get()`
```lua
obj.getTime("Name"(STR))
-- имя объекта
```
#### obj.onChange()
Привязка к объекту скрипта, который будет выполняться при каждом изменении объекта
```lua
obj.onChange("Name"(STR), "script.lua"(STR))
-- Name - имя объекта
-- script.lua - имя файла скрипта с расширением
```

Проверка существования объекта:
```lua
local status = obj.get("security.status")
if (status == nil) then status = 0 end
```
Для изменения типа переменной сохраняемого значения можно сделать так:
```lua
obj.setOpt("security.status", "INT")
```

Получение времени события в секундах lua list (curr,prev):
```lua
curr, prev = obj.getTime("security.status")
print("Время предыдущего изменения:" .. prev .. ", И последнего: " .. curr .. " длительность события: " .. curr-prev)
```



### http.request 
Вызов URL запроса http.request (`url[:port], [method, headers, body]`)

В данный момент поддерживается только `http://` протокол.

Пример переключение gpio 12 для прошивки wifi-iot
```lua
http.request("http://192.168.1.34/gpio?st=2&pin=12")
```

Пример отправки POST запроса:
```lua
http.request("http://postman-echo.com:80/post?foo1=bar1", "POST", "Content-Type: text/text; charset=utf-8\r\n", "body") 
```

Пример переключения реле sw1 в прошивке espHome:

```lua
http.request("http://192.168.1.71/switch/sw1/toggle", "POST") 
```

Пример переключение gpio для MegaD при однократном нажатии btn_2 пульта Jager
```lua
if Event.State.Value == "btn_2_single"  then
  http.request("http://192.168.2.200/objects/?object=MegaD1-12&op=m&m=switch")
end
```

Запрос инфомации со стороннего ресурса
```lua
local Response = http.request("http://wtfismyip.com/text")
print("My IP: " .. Response)
```
